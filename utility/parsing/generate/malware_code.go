package generate

import (
	"fmt"

	"github.com/TeamPhoneix/go-evil/utility/structure"
	"github.com/TeamPhoneix/go-evil/utility/structure/functions"
	"github.com/s9rA16Bf4/notify_handler/go/notify"
)

// Filters each definied function into the two categories, boot and loop (call functions aren't handled here)
func filter_function_types(d_funcs []functions.Func_t) ([]string, []string) {
	boot_functions := []string{}
	loop_functions := []string{}

	for _, d_func := range d_funcs {

		// Identify the function type
		if d_func.Func_type == "b" {
			boot_functions = append(boot_functions, d_func.Name)

		} else if d_func.Func_type == "l" {
			loop_functions = append(loop_functions, d_func.Name)

		}
	}

	return boot_functions, loop_functions
}

// Converts each sub function into a corresponding set of golang code
// Creates all functions, loop, boot and call
func Generate_go_functions(s_json string) (string, []string, []string) {
	data_object := structure.Receive(s_json)

	boot_func, loop_func := filter_function_types(data_object.Functions)

	// For each of our functions
	for _, d_func := range data_object.Functions {
		data := []string{}

		// Define the header
		if d_func.Func_type == "c" { // it's a call function

			switch d_func.Return_type { // Let's check the return type
			case "string":
				data = append(data, fmt.Sprintf("func %s() string {", d_func.Name))

			case "boolean":
				data = append(data, fmt.Sprintf("func %s() bool {", d_func.Name))

			case "integer":
				data = append(data, fmt.Sprintf("func %s() int {", d_func.Name))

			case "null":
				data = append(data, fmt.Sprintf("func %s(){", d_func.Name)) // There is nothing special about this type

			default:
				notify.Error(fmt.Sprintf("Unknown return type '%s'", d_func.Return_type), "function_construction.generate_go_functions()")
			}
		} else {
			data = append(data, fmt.Sprintf("func %s(){", d_func.Name))
		}

		converted_code, s_json := Generate_golang_code(d_func.Gut, structure.Send(data_object)) // Generate the body code

		data = append(data, converted_code...)

		switch d_func.Return_type {
		case "string":
			data = append(data, "return \"\"")
		case "boolean":
			data = append(data, "return true")
		case "integer":
			data = append(data, "return 0")

		default: // Do nothing
		}

		data = append(data, "}") // And add the footer

		data_object = structure.Receive(s_json)
		data_object.Add_go_function(data)
	}

	return structure.Send(data_object), boot_func, loop_func
}
