package main
import (
"github.com/s9rA16Bf4/go-evil/utility/tools"
"github.com/s9rA16Bf4/notify_handler/go/notify"
"regexp"
"strings"
"fmt"
"crypto/rsa"
"os"
"github.com/s9rA16Bf4/ArgumentParser/go/arguments"
)
type var_t struct {
values  []string
foreach string
roof int
pointer int
}
type crypt_t struct {
method string
target []string
aes_key string
aes_key_length int
rsa_public rsa.PublicKey
rsa_private *rsa.PrivateKey
rsa_key_length int
target_extension bool
extension string
}
type alpha_t struct {
alphabet []string
}
type spine_t struct {
variable  var_t
crypt crypt_t
path string
alpha alpha_t
logging_lvl string
is_admin bool
terminate bool
return_code int
}
const (
GRAB_VAR = "(€([0-9]+)€)"
)
var spine spine_t
func  (obj *var_t) set(value string,)  {
obj.values[obj.pointer] = value
obj.pointer++
if obj.pointer >= obj.roof {
obj.pointer = 0
}
}
func  (obj *var_t) get(line string,) string {
regex := regexp.MustCompile(GRAB_VAR)
result := regex.FindAllStringSubmatch(line, -1)
toReturn := line
if len(result) > 0 {
for _, value := range result {
i_number := tools.String_to_int(value[2])
grabbed_value := "NULL"
if i_number != -1 {
if i_number > 0 && i_number < 5 {
grabbed_value = obj.values[i_number-1]
} else {
switch i_number {
case 13:
grabbed_value = obj.foreach
case 23:
grabbed_value = tools.Grab_executable_name()
case 39:
grabbed_value = tools.Grab_CWD()
case 40:
grabbed_value = tools.Grab_home_dir()
case 666:
grabbed_value = tools.Grab_username()
default:
spine.log(fmt.Sprintf("Error, unknown value '%d'", i_number))
}
}
line = strings.ReplaceAll(line, value[1], grabbed_value)
}
}
toReturn = line
}
return toReturn
return ""
}
func  (obj *crypt_t) set_crypto(value string,)  {
obj.method = value
}
func  (obj *crypt_t) set_aes_key(value string,)  {
obj.aes_key = value
obj.aes_key_length = len(value)
}
func  (obj *crypt_t) set_rsa_key(private_key *rsa.PrivateKey,key_length int,)  {
obj.rsa_private = private_key
obj.rsa_public = private_key.PublicKey
obj.rsa_key_length = key_length
}
func  (obj *crypt_t) add_target(value string,)  {
obj.target = append(obj.target, value)
}
func  (obj *alpha_t) construct_string(value []int,) string {
to_return := ""
for _, number := range value{
to_return += obj.alphabet[number]
}
return to_return
return ""
}
func  (obj *spine_t) check_privileges()  {
_, err := os.Open("/etc/sudoers")
if err != nil{
obj.is_admin = false
}else{
obj.is_admin = true
}
}
func  (obj *spine_t) log(msg string,)  {
notify.Log(msg, spine.logging_lvl, "3")
}
func  Outln(repr_1  []int,)  {
s_msg := spine.variable.get(spine.alpha.construct_string(repr_1))
fmt.Println(s_msg)
}
func  Out(repr_1  []int,)  {
s_msg := spine.variable.get(spine.alpha.construct_string(repr_1))
fmt.Print(s_msg)
}
func  Exit(repr_1 []int,)  {
lvl := spine.variable.get(spine.alpha.construct_string(repr_1))
spine.return_code = tools.String_to_int(lvl)
spine.terminate = true
}
func  main_func()  {
Outln([]int{43,14,21,21,24,93,32,18,29,17,93,10,93,23,14,32,21,18,23,14,62,})
Out([]int{43,14,21,21,24,93,32,18,29,17,24,30,29,93,10,93,23,14,32,21,18,23,14,62,})
Exit([]int{0,})
}
func  main()  {
arguments.Argument_add("--verbose", "-v", false, "Show all generated logs during runtime")
parsed := arguments.Argument_parse()
if _, ok := parsed["-v"]; ok{
spine.logging_lvl = "3"
}
spine.alpha.alphabet = []string{"0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","!","#","$","€","%","&","(",")","*","+","","","-",".","/",":",";","<","=",">","?","@","[","]","^","_","`","{","|","}","~"," ","%t","%n","%r","%x0b","%x0c",}
spine.terminate = false
spine.return_code = 0
spine.variable.roof = 5
spine.variable.pointer = 0
spine.variable.values = make([]string, spine.variable.roof)
spine.variable.values[0] = "NULL"
spine.variable.values[1] = "NULL"
spine.variable.values[2] = "NULL"
spine.variable.values[3] = "NULL"
spine.variable.values[4] = "NULL"
spine.check_privileges()
spine.path = tools.Grab_executable_path()
for !spine.terminate {
main_func()
}
os.Exit(spine.return_code)
}
